pipeline {
    agent any
    
    environment {
        CONFIG_FILE = 'config/global-config.env'
        VENV_PATH = '/var/lib/jenkins/mlops-venv'
    }
    
    stages {

        stage('Setup & Load Configuration') {
            steps {
                sh '''#!/bin/bash
                echo "üêç Setting up Python environment..."
                if [ ! -d "${VENV_PATH}" ]; then
                    python3 -m venv ${VENV_PATH}
                fi
                source ${VENV_PATH}/bin/activate
                pip install --upgrade pip
                pip install mlflow bentoml scikit-learn pandas numpy joblib faker seaborn matplotlib fastapi uvicorn
                echo "‚úÖ Python environment ready"
                
                echo "üîß Loading configuration..."
                if [ -f "${CONFIG_FILE}" ]; then
                    # Source the config file
                    set -a
                    source ${CONFIG_FILE}
                    set +a
                    
                    # Generate dynamic Docker tag
                    export DOCKER_IMAGE_TAG="v$(date +%Y%m%d-%H%M%S)"
                    
                    # Create environment variables file for Jenkins
                    cat > env.properties << EOF
AWS_REGION=${AWS_REGION}
AWS_ACCOUNT_ID=${AWS_ACCOUNT_ID}
ECR_REPO_NAME=${ECR_REPO_NAME}
ECR_REPO_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}
CLUSTER_NAME=${CLUSTER_NAME}
K8S_NAMESPACE=${K8S_NAMESPACE}
TERRAFORM_DIR=${TERRAFORM_DIR}
SONAR_PROJECT_KEY=${SONAR_PROJECT_KEY}
SONAR_HOST_URL=${SONAR_HOST_URL}
DOCKER_IMAGE_TAG=${DOCKER_IMAGE_TAG}
MLFLOW_EXPERIMENT_NAME=${MLFLOW_EXPERIMENT_NAME}
MAX_MLFLOW_RUNS_TO_KEEP=${MAX_MLFLOW_RUNS_TO_KEEP}
EOF
                    
                    echo "‚úÖ Configuration loaded:"
                    cat env.properties
                    
                    # Verify critical variables
                    if [ -z "${AWS_REGION}" ] || [ -z "${CLUSTER_NAME}" ] || [ -z "${ECR_REPO_NAME}" ]; then
                        echo "‚ùå Critical configuration variables are missing!"
                        exit 1
                    fi
                    
                    echo "‚úÖ Configuration verification passed"
                else
                    echo "‚ùå Configuration file not found: ${CONFIG_FILE}"
                    exit 1
                fi
                '''
                
                script {
                    // Read environment variables using basic shell commands
                    def envContent = sh(returnStdout: true, script: 'cat env.properties').trim()
                    
                    // Parse each line and set environment variables
                    envContent.split('\n').each { line ->
                        if (line.contains('=')) {
                            def parts = line.split('=', 2)
                            def key = parts[0].trim()
                            def value = parts[1].trim()
                            env.setProperty(key, value)
                            echo "Loaded: ${key} = ${value}"
                        }
                    }
                    
                    echo "‚úÖ All configuration loaded successfully"
                }
            }
        }

        stage('Code Quality & Security') {
            parallel {
                stage('SonarQube Code Scan') {
                    steps {
                        script {
                            try {
                                withCredentials([string(credentialsId: 'sonarqube-creds', variable: 'SONAR_AUTH_TOKEN')]) {
                                    sh '''#!/bin/bash
                                    echo "üìä Running SonarQube code quality scan..."
                                    echo "üîç SonarQube URL: ${SONAR_HOST_URL}"
                                    echo "üìã Project Key: ${SONAR_PROJECT_KEY}"
                                    
                                    # Test SonarQube connectivity first
                                    if curl -s -f "${SONAR_HOST_URL}/api/system/status" > /dev/null; then
                                        echo "‚úÖ SonarQube container is accessible"
                                        
                                        # Test authentication
                                        AUTH_TEST=$(curl -s -w "%{http_code}" -H "Authorization: Bearer ${SONAR_AUTH_TOKEN}" "${SONAR_HOST_URL}/api/authentication/validate" -o /dev/null)
                                        
                                        if [ "$AUTH_TEST" = "200" ]; then
                                            echo "‚úÖ SonarQube authentication successful"
                                            
                                            # Run SonarQube scan
                                            docker run --rm \
                                                --network host \
                                                -v $(pwd):/usr/src \
                                                -w /usr/src \
                                                sonarsource/sonar-scanner-cli:latest \
                                                sonar-scanner \
                                                -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                                                -Dsonar.sources=src \
                                                -Dsonar.host.url=${SONAR_HOST_URL} \
                                                -Dsonar.token=${SONAR_AUTH_TOKEN} \
                                                -Dsonar.qualitygate.wait=false
                                                
                                            echo "‚úÖ SonarQube scan completed successfully"
                                        else
                                            echo "‚ùå SonarQube authentication failed (HTTP: $AUTH_TEST)"
                                            echo "Please check the SonarQube token in Jenkins credentials"
                                            exit 1
                                        fi
                                    else
                                        echo "‚ùå SonarQube container not accessible at ${SONAR_HOST_URL}"
                                        echo "Please ensure SonarQube is running"
                                        exit 1
                                    fi
                                    '''
                                }
                            } catch (Exception e) {
                                echo "‚ùå SonarQube scan failed: ${e.getMessage()}"
                                echo "‚ö†Ô∏è Continuing pipeline without SonarQube scan"
                                currentBuild.result = 'UNSTABLE'
                            }
                        }
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        sh '''#!/bin/bash
                        echo "üîí Running security scan..."
                        trivy fs . > trivy-fs-report.txt || true
                        echo "‚úÖ Security scan completed"
                        
                        # Show summary of findings
                        if [ -f trivy-fs-report.txt ]; then
                            echo "üìÑ Security scan summary:"
                            grep -E "(CRITICAL|HIGH)" trivy-fs-report.txt | wc -l || echo "No critical/high vulnerabilities found"
                        fi
                        '''
                    }
                }
            }
        }

        stage('ML Pipeline') {
            steps {
                sh '''#!/bin/bash
                echo "ü§ñ Running ML pipeline..."
                source ${VENV_PATH}/bin/activate
                
                # Start MLflow server in background
                echo "üîÑ Starting MLflow tracking server..."
                export MLFLOW_TRACKING_URI="file:./mlruns"
                
                # Check if MLflow server is already running
                if ! pgrep -f "mlflow server" > /dev/null; then
                    mlflow server --host 0.0.0.0 --port 5000 --backend-store-uri file:./mlruns --default-artifact-root ./mlartifacts --serve-artifacts &
                    MLFLOW_PID=$!
                    echo "Started MLflow server with PID: $MLFLOW_PID"
                    sleep 10  # Give server time to start
                else
                    echo "MLflow server is already running"
                fi
                
                # Test MLflow connectivity
                for i in {1..5}; do
                    if curl -s http://localhost:5000/health > /dev/null; then
                        echo "‚úÖ MLflow server is accessible"
                        break
                    else
                        echo "Waiting for MLflow server... ($i/5)"
                        sleep 5
                    fi
                done
                
                # Set environment for MLflow
                export MLFLOW_TRACKING_URI="http://localhost:5000"
                
                # MLflow cleanup using config variables
                echo "üßπ Cleaning up old MLflow runs (keeping ${MAX_MLFLOW_RUNS_TO_KEEP})..."
                python3 scripts/cleanup_mlflow.py || echo "MLflow cleanup failed, continuing..."
                
                # Generate data and train model
                echo "üìä Generating training data..."
                python3 src/generate_data.py
                
                # Verify data was created
                if [ ! -f "data/transactions.csv" ]; then
                    echo "‚ùå Data generation failed"
                    exit 1
                fi
                
                echo "üéì Training models..."
                export MLFLOW_TRACKING_URI="http://localhost:5000"
                python3 src/train_model.py
                
                # Verify model exists
                if [ ! -f "models/best_model.pkl" ]; then
                    echo "‚ùå Model training failed - no model file created"
                    exit 1
                fi
                
                echo "üåê MLflow UI available at: http://localhost:5000"
                echo "‚úÖ ML pipeline completed successfully"
                '''
            }
        }

        stage('Infrastructure Deployment') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    script {
                        try {
                            dir("${env.TERRAFORM_DIR}") {
                                sh '''#!/bin/bash
                                echo "üèóÔ∏è Deploying AWS infrastructure using Terraform..."
                                echo "üìÇ Working in directory: $(pwd)"
                                echo "üìÅ Terraform files:"
                                ls -la *.tf || { echo "‚ùå No Terraform files found!"; exit 1; }
                                
                                # Configure AWS credentials
                                export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
                                export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
                                export AWS_DEFAULT_REGION=${AWS_REGION}
                                
                                # Verify AWS credentials
                                echo "üîç Verifying AWS credentials..."
                                aws sts get-caller-identity || { echo "‚ùå AWS credentials invalid"; exit 1; }
                                
                                echo "üîß Terraform initialization..."
                                terraform init
                                
                                echo "üîç Terraform validation..."
                                terraform validate || { echo "‚ùå Terraform configuration invalid"; exit 1; }
                                
                                echo "üìã Terraform planning..."
                                terraform plan \
                                    -var="region=${AWS_REGION}" \
                                    -var="cluster_name=${CLUSTER_NAME}" \
                                    -var="aws_account_id=${AWS_ACCOUNT_ID}" \
                                    -out=tfplan
                                
                                echo "üöÄ Terraform applying..."
                                terraform apply -auto-approve tfplan
                                
                                echo "‚úÖ Infrastructure deployment completed"
                                
                                # Output important information
                                terraform output
                                '''
                            }
                        } catch (Exception e) {
                            echo "‚ùå Infrastructure deployment failed: ${e.getMessage()}"
                            currentBuild.result = 'FAILURE'
                            error("Infrastructure deployment failed")
                        }
                    }
                }
            }
        }

        stage('Container Build & Push') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''#!/bin/bash
                    echo "üê≥ Building and pushing Docker container..."
                    echo "üì¶ Image: ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}"
                    
                    # Configure AWS
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set default.region ${AWS_REGION}
                    
                    # Create ECR repository if it doesn't exist
                    echo "üèóÔ∏è Ensuring ECR repository exists..."
                    aws ecr describe-repositories --repository-names ${ECR_REPO_NAME} --region ${AWS_REGION} 2>/dev/null || \
                    aws ecr create-repository --repository-name ${ECR_REPO_NAME} --region ${AWS_REGION}

                    # Build Docker image
                    echo "üî® Building Docker image..."
                    docker build -t ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} .
                    
                    # Test the built image
                    echo "üß™ Testing Docker image..."
                    docker run -d --name test-container -p 3001:3000 ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG}
                    sleep 10
                    
                    # Test health endpoint
                    if curl -f http://localhost:3001/healthz; then
                        echo "‚úÖ Container health check passed"
                    else
                        echo "‚ö†Ô∏è Container health check failed"
                    fi
                    
                    # Stop and remove test container
                    docker stop test-container || true
                    docker rm test-container || true
                    
                    # Login to ECR
                    echo "üîê Logging into ECR..."
                    aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URI}
                    
                    # Tag and push
                    echo "üì§ Pushing to ECR..."
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    docker push ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    
                    # Also tag as latest
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:latest
                    docker push ${ECR_REPO_URI}:latest
                    
                    # Security scan
                    echo "üîí Running container security scan..."
                    trivy image ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} > trivy-image-report.txt || true
                    
                    echo "‚úÖ Container ready: ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}"
                    '''
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    script {
                        try {
                            sh '''#!/bin/bash
                            echo "üöÄ Deploying to Kubernetes cluster: ${CLUSTER_NAME}"
                            
                            # Configure AWS
                            aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                            aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                            aws configure set default.region ${AWS_REGION}
                            
                            # Check if cluster exists
                            echo "üîç Checking EKS cluster status..."
                            if aws eks describe-cluster --name ${CLUSTER_NAME} --region ${AWS_REGION} > /dev/null 2>&1; then
                                echo "‚úÖ EKS cluster '${CLUSTER_NAME}' found"
                                
                                # Wait for EKS cluster to be ready
                                echo "‚è≥ Waiting for EKS cluster to be active..."
                                aws eks wait cluster-active --name ${CLUSTER_NAME} --region ${AWS_REGION} --cli-read-timeout 300
                                
                                # Configure kubectl
                                echo "‚öì Configuring kubectl for cluster: ${CLUSTER_NAME}"
                                aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                                
                                # Verify cluster access
                                echo "üîç Verifying cluster access..."
                                kubectl get nodes
                                
                                # Deploy with Helm using config variables
                                echo "üì¶ Deploying to namespace: ${K8S_NAMESPACE}"
                                
                                # Update Helm values with current image tag
                                helm upgrade --install fraud-detection k8s/helm \
                                    --namespace ${K8S_NAMESPACE} \
                                    --create-namespace \
                                    --values k8s/helm/values-production.yaml \
                                    --set image.repository=${ECR_REPO_URI} \
                                    --set image.tag=${DOCKER_IMAGE_TAG} \
                                    --timeout=10m \
                                    --wait
                                
                                # Wait for deployment to be ready
                                echo "‚è≥ Waiting for deployment to be ready..."
                                kubectl wait --for=condition=ready pod -l app=fraud-detection -n ${K8S_NAMESPACE} --timeout=300s
                                
                                # Get service information
                                echo "üìä Deployment status:"
                                kubectl get pods -n ${K8S_NAMESPACE}
                                kubectl get svc fraud-detection -n ${K8S_NAMESPACE} -o wide
                                
                                # Get LoadBalancer URL
                                echo "üåê Getting external endpoint..."
                                sleep 30  # Give load balancer time to provision
                                EXTERNAL_IP=$(kubectl get svc fraud-detection -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
                                
                                # Test the deployment
                                if [ "$EXTERNAL_IP" != "pending" ] && [ ! -z "$EXTERNAL_IP" ]; then
                                    echo "üß™ Testing deployment..."
                                    sleep 60  # Give more time for DNS propagation
                                    
                                    if curl -f -m 30 "http://${EXTERNAL_IP}/healthz"; then
                                        echo "‚úÖ Deployment health check passed"
                                    else
                                        echo "‚ö†Ô∏è Deployment health check failed (this may be normal during initial deployment)"
                                    fi
                                fi
                                
                                echo ""
                                echo "üéâ DEPLOYMENT SUCCESSFUL!"
                                echo "================================================="
                                echo "üåê API Endpoint: http://${EXTERNAL_IP}"
                                echo "üß™ Health Check: http://${EXTERNAL_IP}/healthz"
                                echo "üìö API Documentation: http://${EXTERNAL_IP}/docs"
                                echo "üîç Model Info: http://${EXTERNAL_IP}/info"
                                echo ""
                                echo "üìù Example API calls:"
                                echo "# Health check"
                                echo "curl http://${EXTERNAL_IP}/healthz"
                                echo ""
                                echo "# Single prediction"
                                echo "curl -X POST http://${EXTERNAL_IP}/predict \\"
                                echo "  -H 'Content-Type: application/json' \\"
                                echo "  -d '{\"amount\": 150.0, \"merchant\": \"Amazon\", \"location\": \"NewYork\", \"card_type\": \"Visa\"}'"
                                echo ""
                                echo "# Batch prediction"
                                echo "curl -X POST http://${EXTERNAL_IP}/batch_predict \\"
                                echo "  -H 'Content-Type: application/json' \\"
                                echo "  -d '{\"transactions\": [{\"amount\": 150.0, \"merchant\": \"Amazon\", \"location\": \"NewYork\", \"card_type\": \"Visa\"}]}'"
                                echo "================================================="
                                
                            else
                                echo "‚ùå EKS cluster '${CLUSTER_NAME}' not found"
                                echo "This is likely due to the Terraform infrastructure deployment failure"
                                exit 1
                            fi
                            '''
                        } catch (Exception e) {
                            echo "‚ùå Kubernetes deployment failed: ${e.getMessage()}"
                            currentBuild.result = 'FAILURE'
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            sh '''#!/bin/bash
            echo "üßπ Cleaning up..."
            
            # Stop MLflow server if running
            pkill -f "mlflow server" || true
            
            # Clean up test containers
            docker stop test-container 2>/dev/null || true
            docker rm test-container 2>/dev/null || true
            
            echo "üìÅ Pipeline artifacts:"
            ls -la trivy-*.txt models/*.pkl mlruns/ 2>/dev/null || echo "Some artifacts may not exist"
            '''
            
            // Archive artifacts
            archiveArtifacts artifacts: 'trivy-*.txt', allowEmptyArchive: true
            archiveArtifacts artifacts: 'models/*.pkl', allowEmptyArchive: true
            archiveArtifacts artifacts: 'models/*.json', allowEmptyArchive: true
            archiveArtifacts artifacts: 'data/*.csv', allowEmptyArchive: true
            
            // Publish test results if they exist
            script {
                if (fileExists('test-results.xml')) {
                    publishTestResults testResultsPattern: 'test-results.xml'
                }
            }
        }
        
        success {
            echo 'üéâ COMPLETE PIPELINE SUCCESS!'
            echo "‚úÖ Infrastructure: EKS cluster '${CLUSTER_NAME}' deployed"
            echo "‚úÖ Application: Container '${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}' built and pushed"
            echo "‚úÖ Kubernetes: Service deployed in namespace '${K8S_NAMESPACE}'"
            echo "üåê MLflow UI: http://localhost:5000 (if running locally)"
            
            // Send success notification (if configured)
            script {
                try {
                    emailext (
                        subject: "‚úÖ MLOps Pipeline Success - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                        body: """
                        Pipeline completed successfully!
                        
                        Build: ${env.BUILD_URL}
                        Cluster: ${env.CLUSTER_NAME}
                        Image: ${env.ECR_REPO_URI}:${env.DOCKER_IMAGE_TAG}
                        Namespace: ${env.K8S_NAMESPACE}
                        """,
                        to: "${env.CHANGE_AUTHOR_EMAIL ?: 'dev-team@company.com'}"
                    )
                } catch (Exception e) {
                    echo "Email notification failed: ${e.getMessage()}"
                }
            }
        }
        
        failure {
            echo '‚ùå Pipeline failed. Check logs above for details.'
            sh '''#!/bin/bash
            echo "üîç Configuration values at failure:"
            echo "AWS_REGION: ${AWS_REGION:-NOT_SET}"
            echo "CLUSTER_NAME: ${CLUSTER_NAME:-NOT_SET}"
            echo "ECR_REPO_URI: ${ECR_REPO_URI:-NOT_SET}"
            echo "DOCKER_IMAGE_TAG: ${DOCKER_IMAGE_TAG:-NOT_SET}"
            
            # Show recent logs for debugging
            echo "üìù Recent system logs:"
            tail -50 /var/log/jenkins/jenkins.log 2>/dev/null || echo "Jenkins logs not accessible"
            '''
            
            // Send failure notification (if configured)
            script {
                try {
                    emailext (
                        subject: "‚ùå MLOps Pipeline Failed - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                        body: """
                        Pipeline failed!
                        
                        Build: ${env.BUILD_URL}
                        Failed Stage: ${env.STAGE_NAME}
                        
                        Please check the logs for details.
                        """,
                        to: "${env.CHANGE_AUTHOR_EMAIL ?: 'dev-team@company.com'}"
                    )
                } catch (Exception e) {
                    echo "Email notification failed: ${e.getMessage()}"
                }
            }
        }
        
        unstable {
            echo '‚ö†Ô∏è Pipeline completed with warnings.'
            echo 'Some non-critical steps may have failed (e.g., SonarQube scan)'
        }
    }
}
                
