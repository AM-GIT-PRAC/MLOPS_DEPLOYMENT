// jenkins/Jenkinsfile-native-fixed
// Fixed version with proper shell handling
pipeline {
    agent any
    
    environment {
        CONFIG_FILE = 'config/global-config.env'
        VENV_PATH = '/var/lib/jenkins/mlops-venv'
    }
    
    stage('Load Configuration') {
        steps {
            script {
                if (fileExists(env.CONFIG_FILE)) {
                    sh """#!/bin/bash
                    echo "✅ Found config file: ${CONFIG_FILE}"
                    source ${VENV_PATH}/bin/activate
                    set -a
                    source ${CONFIG_FILE}
                    set +a
                    env | grep -E "AWS_|SONAR_|ECR_|K8S_|DOCKER_|MLFLOW_|GITHUB_|GIT_" > jenkins-runtime.env
                    echo "✅ Environment variables exported"
                    """
                    
                    def props = readProperties file: 'jenkins-runtime.env'
                    props.each { key, value ->
                        env.setProperty(key, value)
                    }
                    echo "✅ Configuration loaded"
                } else {
                    sh "echo '❌ Config file not found at: ${CONFIG_FILE}'; ls -la config/ || echo 'Config dir missing'"
                    error("Configuration file missing")
                }
            }
        }
    }
        
        stage('Load Configuration') {
            steps {
                script {
                    // Load configuration from file only
                    if (fileExists(env.CONFIG_FILE)) {
                        sh """#!/bin/bash
                        source ${VENV_PATH}/bin/activate
                        set -a
                        source ${CONFIG_FILE}
                        set +a
                        env | grep -E "AWS_|SONAR_|ECR_|K8S_|DOCKER_|MLFLOW_|GITHUB_|GIT_" > jenkins-runtime.env
                        """
                        
                        def props = readProperties file: 'jenkins-runtime.env'
                        props.each { key, value ->
                            env.setProperty(key, value)
                        }
                        echo "✅ Configuration loaded from ${CONFIG_FILE}"
                    } else {
                        error("❌ Configuration file not found: ${CONFIG_FILE}")
                    }
                }
            }
        }

        stage('Checkout & Verify') {
            steps {
                sh '''#!/bin/bash
                echo "📂 Verifying repository structure..."
                ls -la
                
                # Verify required files exist
                [ -f "src/train_model.py" ] || { echo "❌ train_model.py not found"; exit 1; }
                [ -f "src/generate_data.py" ] || { echo "❌ generate_data.py not found"; exit 1; }
                [ -f "src/fraud_service.py" ] || { echo "❌ fraud_service.py not found"; exit 1; }
                [ -f "Dockerfile" ] || { echo "❌ Dockerfile not found"; exit 1; }
                
                echo "✅ Repository structure verified"
                '''
            }
        }

        stage('Code Quality & Security') {
            parallel {
                stage('Trivy Security Scan') {
                    steps {
                        sh '''#!/bin/bash
                        echo "🔒 Running security scan..."
                        trivy fs . > trivy-fs-report.txt || true
                        '''
                    }
                }
                
                stage('SonarQube Code Quality') {
                    steps {
                        withCredentials([string(credentialsId: 'sonarqube-creds', variable: 'SONAR_AUTH_TOKEN')]) {
                            sh """#!/bin/bash
                            sonar-scanner \
                                -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                                -Dsonar.sources=src \
                                -Dsonar.host.url=${SONAR_HOST_URL} \
                                -Dsonar.login=${SONAR_AUTH_TOKEN} || true
                            """
                        }
                    }
                }
            }
        }

        stage('ML Pipeline') {
            steps {
                sh '''#!/bin/bash
                echo "🤖 Running ML pipeline..."
                source ${VENV_PATH}/bin/activate
                
                # Step 1: Generate training data
                echo "📊 Generating training data..."
                python3 src/generate_data.py
                
                # Step 2: Train models
                echo "🎓 Training models..."
                python3 src/train_model.py
                
                # Step 3: Verify outputs
                [ -f "data/transactions.csv" ] || { echo "❌ Training data not generated"; exit 1; }
                [ -f "models/best_model.pkl" ] || { echo "❌ Model training failed"; exit 1; }
                
                echo "✅ ML pipeline completed successfully"
                '''
            }
        }

        stage('Application Testing') {
            steps {
                sh '''#!/bin/bash
                echo "🧪 Testing application components..."
                source ${VENV_PATH}/bin/activate
                
                # Test model loading
                python3 -c "
import joblib
import os
model = joblib.load('models/best_model.pkl')
print(f'✅ Model loads: {type(model).__name__}')
"
                
                # Test service imports
                python3 -c "
import sys
sys.path.append('src')
from fraud_service import svc
print('✅ BentoML service imports successfully')
"
                
                echo "✅ Application tests passed"
                '''
            }
        }

        stage('Infrastructure') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir("${env.TERRAFORM_DIR}") {
                        sh '''#!/bin/bash
                        echo "🏗️ Managing infrastructure..."
                        
                        export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
                        export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
                        export AWS_DEFAULT_REGION=${AWS_REGION}
                        
                        terraform init
                        terraform plan
                        terraform apply -auto-approve
                        
                        echo "✅ Infrastructure ready"
                        '''
                    }
                }
            }
        }

        stage('Container Build & Push') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''#!/bin/bash
                    echo "🐳 Building and pushing container..."
                    
                    # Configure AWS
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set default.region ${AWS_REGION}

                    # Build image
                    docker build -t ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} .
                    
                    # Push to ECR
                    aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URI}
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    docker push ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    
                    # Security scan
                    trivy image ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} > trivy-image-report.txt || true
                    
                    echo "✅ Container ready: ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}"
                    '''
                }
            }
        }

        stage('Deploy to Production') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''#!/bin/bash
                    echo "🚀 Deploying to production..."
                    
                    # Configure kubectl
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set default.region ${AWS_REGION}
                    aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                    
                    # Deploy with Helm
                    helm upgrade --install fraud-detection k8s/helm \
                        --namespace ${K8S_NAMESPACE} \
                        --create-namespace \
                        --values k8s/helm/values-production.yaml \
                        --set image.repository=${ECR_REPO_URI} \
                        --set image.tag=${DOCKER_IMAGE_TAG} \
                        --timeout=10m
                    
                    # Wait and verify
                    kubectl wait --for=condition=ready pod -l app=fraud-detection -n ${K8S_NAMESPACE} --timeout=300s
                    
                    # Get endpoint
                    EXTERNAL_IP=$(kubectl get svc fraud-detection -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
                    
                    echo "🎉 Deployment completed!"
                    echo "🌐 API endpoint: http://${EXTERNAL_IP}"
                    '''
                }
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: 'trivy-*.txt', allowEmptyArchive: true
            archiveArtifacts artifacts: 'models/*.pkl', allowEmptyArchive: true
        }
        success {
            echo '✅ Pipeline completed successfully!'
        }
        failure {
            echo '❌ Pipeline failed. Check logs for details.'
        }
    }
}
