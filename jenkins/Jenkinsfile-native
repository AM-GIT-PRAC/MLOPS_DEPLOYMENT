pipeline {
    agent any
    
    environment {
        CONFIG_FILE = 'config/global-config.env'
        VENV_PATH = '/var/lib/jenkins/mlops-venv'
    }
    
    stages {

        stage('Setup & Load Configuration') {
            steps {
                sh '''#!/bin/bash
                echo "üêç Setting up Python environment..."
                if [ ! -d "${VENV_PATH}" ]; then
                    python3 -m venv ${VENV_PATH}
                fi
                source ${VENV_PATH}/bin/activate
                pip install --upgrade pip
                pip install mlflow bentoml scikit-learn pandas numpy joblib faker seaborn matplotlib fastapi uvicorn
                echo "‚úÖ Python environment ready"
                
                echo "üîß Loading configuration..."
                if [ -f "${CONFIG_FILE}" ]; then
                    set -a
                    source ${CONFIG_FILE}
                    set +a
                    
                    export DOCKER_IMAGE_TAG="v$(date +%Y%m%d-%H%M%S)"
                    
                    cat > env.properties << EOF
AWS_REGION=${AWS_REGION}
AWS_ACCOUNT_ID=${AWS_ACCOUNT_ID}
ECR_REPO_NAME=${ECR_REPO_NAME}
ECR_REPO_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}
CLUSTER_NAME=${CLUSTER_NAME}
K8S_NAMESPACE=${K8S_NAMESPACE}
TERRAFORM_DIR=${TERRAFORM_DIR}
SONAR_PROJECT_KEY=${SONAR_PROJECT_KEY}
SONAR_HOST_URL=${SONAR_HOST_URL}
DOCKER_IMAGE_TAG=${DOCKER_IMAGE_TAG}
MLFLOW_EXPERIMENT_NAME=${MLFLOW_EXPERIMENT_NAME}
MAX_MLFLOW_RUNS_TO_KEEP=${MAX_MLFLOW_RUNS_TO_KEEP}
EOF
                    
                    echo "‚úÖ Configuration loaded:"
                    cat env.properties
                    
                    if [ -z "${AWS_REGION}" ] || [ -z "${CLUSTER_NAME}" ] || [ -z "${ECR_REPO_NAME}" ]; then
                        echo "‚ùå Critical configuration variables missing!"
                        exit 1
                    fi
                    
                    echo "‚úÖ Configuration verification passed"
                else
                    echo "‚ùå Configuration file not found: ${CONFIG_FILE}"
                    exit 1
                fi
                '''
                
                script {
                    def envContent = sh(returnStdout: true, script: 'cat env.properties').trim()
                    envContent.split('\n').each { line ->
                        if (line.contains('=')) {
                            def parts = line.split('=', 2)
                            def key = parts[0].trim()
                            def value = parts[1].trim()
                            env.setProperty(key, value)
                            echo "Loaded: ${key} = ${value}"
                        }
                    }
                    echo "‚úÖ All configuration loaded successfully"
                }
            }
        }

        stage('Code Quality & Security') {
            parallel {
                stage('SonarQube Code Scan') {
                    steps {
                        script {
                            try {
                                withCredentials([string(credentialsId: 'sonarqube-creds', variable: 'SONAR_AUTH_TOKEN')]) {
                                    sh '''#!/bin/bash
                                    echo "üìä Running SonarQube code quality scan..."
                                    echo "üîç SonarQube URL: ${SONAR_HOST_URL}"
                                    echo "üìã Project Key: ${SONAR_PROJECT_KEY}"
                                    
                                    if curl -s -f "${SONAR_HOST_URL}/api/system/status" > /dev/null; then
                                        echo "‚úÖ SonarQube accessible"
                                        
                                        AUTH_TEST=$(curl -s -w "%{http_code}" -H "Authorization: Bearer ${SONAR_AUTH_TOKEN}" "${SONAR_HOST_URL}/api/authentication/validate" -o /dev/null)
                                        
                                        if [ "$AUTH_TEST" = "200" ]; then
                                            echo "‚úÖ Authentication successful"
                                            
                                            docker run --rm \
                                                --network host \
                                                -v $(pwd):/usr/src \
                                                -w /usr/src \
                                                sonarsource/sonar-scanner-cli:latest \
                                                sonar-scanner \
                                                -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                                                -Dsonar.projectName="MLOps Fraud Detection" \
                                                -Dsonar.sources=src \
                                                -Dsonar.host.url=${SONAR_HOST_URL} \
                                                -Dsonar.token=${SONAR_AUTH_TOKEN} \
                                                -Dsonar.qualitygate.wait=false
                                                
                                            echo "‚úÖ SonarQube scan completed"
                                            echo "üìä View results: ${SONAR_HOST_URL}/dashboard?id=${SONAR_PROJECT_KEY}"
                                        else
                                            echo "‚ùå Authentication failed (HTTP: $AUTH_TEST)"
                                            exit 1
                                        fi
                                    else
                                        echo "‚ùå SonarQube not accessible"
                                        exit 1
                                    fi
                                    '''
                                }
                            } catch (Exception e) {
                                echo "‚ùå SonarQube scan failed: ${e.getMessage()}"
                                currentBuild.result = 'UNSTABLE'
                            }
                        }
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        sh '''#!/bin/bash
                        echo "üîí Running security scan..."
                        trivy fs . > trivy-fs-report.txt || true
                        echo "‚úÖ Security scan completed"
                        
                        if [ -f trivy-fs-report.txt ]; then
                            echo "üìÑ Security findings:"
                            grep -E "(CRITICAL|HIGH)" trivy-fs-report.txt | wc -l || echo "No critical/high vulnerabilities"
                        fi
                        '''
                    }
                }
            }
        }

        stage('Verify Static Data') {
            steps {
                sh '''#!/bin/bash
                echo "üìä Verifying static training data..."
                
                # Check if static data exists
                if [ -f "data/transactions.csv" ]; then
                    echo "‚úÖ Static data found: data/transactions.csv"
                    
                    # Show data info
                    echo "üìà Data summary:"
                    head -5 data/transactions.csv
                    echo ""
                    echo "üìä Data size:"
                    wc -l data/transactions.csv
                    
                    # Check metadata
                    if [ -f "data/dataset_metadata.json" ]; then
                        echo "‚úÖ Metadata found"
                        cat data/dataset_metadata.json | head -20
                    fi
                    
                    # Check feature mapping
                    if [ -f "data/feature_mapping.json" ]; then
                        echo "‚úÖ Feature mapping found"
                    fi
                    
                else
                    echo "‚ùå Static data not found!"
                    echo "Please generate data first:"
                    echo "  python3 src/generate_data.py"
                    echo "  git add data/"
                    echo "  git commit -m 'Add training data'"
                    echo "  git push"
                    exit 1
                fi
                '''
            }
        }

        stage('ML Pipeline - Training Only') {
            steps {
                sh '''#!/bin/bash
                echo "ü§ñ Running ML training with static data..."
                source ${VENV_PATH}/bin/activate
                
                # Start MLflow server
                echo "üîÑ Starting MLflow server..."
                if ! pgrep -f "mlflow server" > /dev/null; then
                    mlflow server --host 0.0.0.0 --port 5000 --backend-store-uri file:./mlruns --default-artifact-root ./mlartifacts --serve-artifacts &
                    sleep 10
                fi
                
                export MLFLOW_TRACKING_URI="http://localhost:5000"
                
                # MLflow cleanup
                echo "üßπ Cleaning up old MLflow runs..."
                python3 scripts/cleanup_mlflow.py || echo "Cleanup failed, continuing..."
                
                # Train models (NO data generation)
                echo "üéì Training models with static data..."
                python3 src/train_model.py
                
                # Verify model was created
                if [ ! -f "models/best_model.pkl" ]; then
                    echo "‚ùå Model training failed - no model file created"
                    exit 1
                fi
                
                echo "üìä Model info:"
                ls -la models/
                
                echo "üåê MLflow UI: http://localhost:5000"
                echo "‚úÖ ML training completed successfully"
                '''
            }
        }

        stage('Infrastructure Deployment') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    script {
                        try {
                            dir("${env.TERRAFORM_DIR}") {
                                sh '''#!/bin/bash
                                echo "üèóÔ∏è Deploying AWS infrastructure..."
                                
                                export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
                                export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
                                export AWS_DEFAULT_REGION=${AWS_REGION}
                                
                                echo "üîç Verifying AWS credentials..."
                                aws sts get-caller-identity
                                
                                echo "üîß Terraform init..."
                                terraform init
                                
                                echo "üîç Terraform validate..."
                                terraform validate
                                
                                echo "üìã Terraform plan..."
                                terraform plan \
                                    -var="region=${AWS_REGION}" \
                                    -var="cluster_name=${CLUSTER_NAME}" \
                                    -var="aws_account_id=${AWS_ACCOUNT_ID}" \
                                    -out=tfplan
                                
                                echo "üöÄ Terraform apply..."
                                terraform apply -auto-approve tfplan
                                
                                echo "‚úÖ Infrastructure deployment completed"
                                terraform output
                                '''
                            }
                        } catch (Exception e) {
                            echo "‚ùå Infrastructure deployment failed: ${e.getMessage()}"
                            currentBuild.result = 'FAILURE'
                            error("Infrastructure deployment failed")
                        }
                    }
                }
            }
        }

        stage('Container Build & Push') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''#!/bin/bash
                    echo "üê≥ Building and pushing Docker container..."
                    echo "üì¶ Image: ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}"
                    
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set default.region ${AWS_REGION}
                    
                    # Ensure ECR repository exists
                    aws ecr describe-repositories --repository-names ${ECR_REPO_NAME} --region ${AWS_REGION} 2>/dev/null || \
                    aws ecr create-repository --repository-name ${ECR_REPO_NAME} --region ${AWS_REGION}

                    # Build Docker image
                    echo "üî® Building image..."
                    docker build -t ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} .
                    
                    # Test container
                    echo "üß™ Testing container..."
                    docker run -d --name test-fraud -p 3001:3000 ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG}
                    sleep 15
                    
                    if curl -f http://localhost:3001/healthz; then
                        echo "‚úÖ Container health check passed"
                    else
                        echo "‚ö†Ô∏è Container health check failed"
                    fi
                    
                    docker stop test-fraud && docker rm test-fraud
                    
                    # Login to ECR and push
                    echo "üì§ Pushing to ECR..."
                    aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URI}
                    
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    docker push ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:latest
                    docker push ${ECR_REPO_URI}:latest
                    
                    # Security scan
                    echo "üîí Container security scan..."
                    trivy image ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} > trivy-image-report.txt || true
                    
                    echo "‚úÖ Container ready: ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}"
                    '''
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    script {
                        try {
                            sh '''#!/bin/bash
                            echo "üöÄ Deploying to Kubernetes..."
                            
                            aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                            aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                            aws configure set default.region ${AWS_REGION}
                            
                            if aws eks describe-cluster --name ${CLUSTER_NAME} --region ${AWS_REGION} > /dev/null 2>&1; then
                                echo "‚úÖ EKS cluster found"
                                
                                echo "‚è≥ Waiting for cluster..."
                                aws eks wait cluster-active --name ${CLUSTER_NAME} --region ${AWS_REGION}
                                
                                echo "‚öì Configuring kubectl..."
                                aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
                                
                                echo "üîç Checking nodes..."
                                kubectl get nodes
                                
                                echo "üì¶ Deploying to ${K8S_NAMESPACE}..."
                                helm upgrade --install fraud-detection k8s/helm \
                                    --namespace ${K8S_NAMESPACE} \
                                    --create-namespace \
                                    --values k8s/helm/values-production.yaml \
                                    --set image.repository=${ECR_REPO_URI} \
                                    --set image.tag=${DOCKER_IMAGE_TAG} \
                                    --timeout=10m \
                                    --wait
                                
                                echo "‚è≥ Waiting for pods..."
                                kubectl wait --for=condition=ready pod -l app=fraud-detection -n ${K8S_NAMESPACE} --timeout=300s
                                
                                echo "üìä Deployment status:"
                                kubectl get pods,svc -n ${K8S_NAMESPACE}
                                
                                # Get external endpoint
                                sleep 30
                                EXTERNAL_IP=$(kubectl get svc fraud-detection -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
                                
                                echo ""
                                echo "üéâ DEPLOYMENT SUCCESSFUL!"
                                echo "================================"
                                echo "üåê API Endpoint: http://${EXTERNAL_IP}"
                                echo "üß™ Health: http://${EXTERNAL_IP}/healthz"
                                echo "üîç Info: http://${EXTERNAL_IP}/info"
                                echo ""
                                echo "üìù Test prediction:"
                                echo 'curl -X POST http://'${EXTERNAL_IP}'/predict \\'
                                echo '  -H "Content-Type: application/json" \\'
                                echo '  -d '"'"'{"amount": 150.0, "merchant": "Amazon", "location": "NewYork", "card_type": "Visa"}'"'"
                                echo "================================"
                                
                            else
                                echo "‚ùå EKS cluster not found"
                                exit 1
                            fi
                            '''
                        } catch (Exception e) {
                            echo "‚ùå Kubernetes deployment failed: ${e.getMessage()}"
                            currentBuild.result = 'FAILURE'
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            sh '''#!/bin/bash
            echo "üßπ Cleanup..."
            pkill -f "mlflow server" || true
            docker stop test-fraud 2>/dev/null || true
            docker rm test-fraud 2>/dev/null || true
            
            echo "üìÅ Artifacts:"
            ls -la trivy-*.txt models/*.pkl data/*.csv 2>/dev/null || echo "Some artifacts missing"
            '''
            
            archiveArtifacts artifacts: 'trivy-*.txt', allowEmptyArchive: true
            archiveArtifacts artifacts: 'models/*.pkl', allowEmptyArchive: true
            archiveArtifacts artifacts: 'models/*.json', allowEmptyArchive: true
        }
        
        success {
            echo 'üéâ PIPELINE SUCCESS!'
            echo "‚úÖ Static data used for training"
            echo "‚úÖ Infrastructure: EKS cluster deployed"
            echo "‚úÖ Application: Container deployed to Kubernetes"
            echo "‚úÖ API: Fraud detection service ready"
            echo "üåê MLflow: http://localhost:5000"
        }
        
        failure {
            echo '‚ùå Pipeline failed'
            sh '''#!/bin/bash
            echo "üîç Debug info:"
            echo "AWS_REGION: ${AWS_REGION:-NOT_SET}"
            echo "CLUSTER_NAME: ${CLUSTER_NAME:-NOT_SET}"
            echo "Static data exists: $(test -f data/transactions.csv && echo 'YES' || echo 'NO')"
            echo "Model exists: $(test -f models/best_model.pkl && echo 'YES' || echo 'NO')"
            '''
        }
    }
}
