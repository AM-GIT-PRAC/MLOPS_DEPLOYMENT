pipeline {
    agent {
        dockerfile {
            filename 'jenkins/Dockerfile.jenkins'
            dir 'jenkins'
            label 'built-in'
        }
    }

    environment {
        ENV_VARS_FILE = 'jenkins/jenkins-env-vars.sh'
    }

    options {
        skipDefaultCheckout true
    }

    stages {

        stage('Load Environment Variables') {
            steps {
                script {
                    def envVars = readFile("${ENV_VARS_FILE}").split("\n")
                    envVars.each {
                        if (it.trim() && it.contains("=")) {
                            def (key, value) = it.tokenize("=")
                            env[key.trim()] = value.trim().replaceAll("\"", "")
                        }
                    }
                }
            }
        }

        stage('Checkout Code') {
            steps {
                git credentialsId: 'github-creds', url: "${env.GITHUB_REPO_URL}", branch: "${env.GIT_BRANCH}"
            }
        }

        stage('Trivy Scan - Source Code') {
            steps {
                sh '''
                echo "Running Trivy filesystem scan..."
                trivy fs . > trivy-fs-report.txt || true
                '''
            }
        }

        stage('SonarQube Code Scan') {
            steps {
                withCredentials([string(credentialsId: 'sonarqube-creds', variable: 'SONAR_AUTH_TOKEN')]) {
                    withSonarQubeEnv('SonarQube Server') {
                        sh """
                        sonar-scanner \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.sources=src \
                            -Dsonar.host.url=${SONAR_HOST_URL} \
                            -Dsonar.login=${SONAR_AUTH_TOKEN}
                        """
                    }
                }
            }
        }

        stage('Terraform Init & Apply') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir("${env.TERRAFORM_DIR}") {
                        sh '''
                        terraform init
                        terraform apply -auto-approve
                        '''
                    }
                }
            }
        }

        stage('Build and Push Docker Image to ECR') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set default.region ${AWS_REGION}

                    aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URI}

                    docker build -t ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} .
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    docker push ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG}
                    '''
                }
            }
        }

        stage('Trivy Scan - Docker Image') {
            steps {
                sh '''
                echo "Running Trivy scan on Docker image..."
                trivy image ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} > trivy-image-report.txt || true
                '''
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                sh '''
                kubectl apply -f ${K8S_DEPLOYMENT_PATH} --namespace=${K8S_NAMESPACE}
                kubectl apply -f ${K8S_SERVICE_PATH} --namespace=${K8S_NAMESPACE}
                '''
            }
        }
    }

    post {
        always {
            echo 'Cleaning up unused containers...'
            sh 'docker container prune -f || true'
        }
        success {
            echo '✅ Pipeline completed successfully.'
        }
        failure {
            echo '❌ Pipeline failed. Please check logs.'
        }
    }
}
