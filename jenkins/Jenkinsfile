pipeline {
    agent {
        dockerfile {
            filename 'Dockerfile.jenkins'
            dir 'jenkins'
            label 'built-in'
            args '-v /var/run/docker.sock:/var/run/docker.sock -u jenkins:docker --entrypoint=""'
        }
    }

    environment {
        ENV_VARS_FILE = 'jenkins/jenkins-env-vars.sh'
    }

    options {
        skipDefaultCheckout false
        timestamps()
    }

    stages {
        stage('Debug Environment') {
            steps {
                sh '''
                echo "Debugging environment..."
                whoami
                id
                groups
                echo "Shell: $SHELL"
                which bash
                which sh
                ls -l /bin/sh /bin/bash
                test -x /bin/sh && echo "/bin/sh is executable" || echo "/bin/sh is not executable"
                test -x /bin/bash && echo "/bin/bash is executable" || echo "/bin/bash is not executable"
                ls -ld /var/lib/jenkins/workspace/MLOPS
                ls -ld /var/lib/jenkins/workspace/MLOPS@tmp || echo "MLOPS@tmp not found"
                ls -l /var/lib/jenkins/workspace/MLOPS@tmp || echo "No files in MLOPS@tmp"
                touch /var/lib/jenkins/workspace/MLOPS@tmp/testfile || echo "Cannot write to workspace"
                echo "Testing shell execution..."
                /bin/sh -c "echo Shell test successful" || echo "Shell test failed"
                /bin/bash -c "echo Bash test successful" || echo "Bash test failed"
                echo "Testing durable task script..."
                echo "echo Test" > /var/lib/jenkins/workspace/MLOPS@tmp/test.sh
                chmod +x /var/lib/jenkins/workspace/MLOPS@tmp/test.sh
                /bin/sh /var/lib/jenkins/workspace/MLOPS@tmp/test.sh || echo "Test script failed"
                env | sort
                docker ps
                echo "Checking SonarQube accessibility..."
                curl -I ${SONAR_HOST_URL} || echo "Warning: SonarQube at ${SONAR_HOST_URL} is not accessible"
                ls -l jenkins/Dockerfile.jenkins || echo "Dockerfile not found"
                ls -l ${ENV_VARS_FILE} || echo "Environment file not found"
                cat ${ENV_VARS_FILE} || echo "Failed to read environment file"
                sonar-scanner --version
                helm version
                kubectl version --client
                terraform version
                trivy --version
                aws --version
                '''
            }
        }

        stage('Load Environment Variables') {
            steps {
                script {
                    def envVars = readFile("${ENV_VARS_FILE}").split("\n")
                    envVars.each {
                        if (it.trim() && it.contains("=")) {
                            def (key, value) = it.tokenize("=")
                            env[key.trim()] = value.trim().replaceAll("\"", "")
                        }
                    }
                    sh 'env | grep -E "GITHUB_REPO_URL|GIT_BRANCH|SONAR|AWS_REGION|ECR|K8S"'
                }
            }
        }

        stage('Checkout Code') {
            steps {
                git credentialsId: 'github-creds', url: "${env.GITHUB_REPO_URL}", branch: "${env.GIT_BRANCH}"
                sh 'git rev-parse HEAD'
            }
        }

        stage('Trivy Scan - Source Code') {
            steps {
                sh '''
                echo "Running Trivy filesystem scan..."
                trivy fs . > trivy-fs-report.txt || true
                '''
            }
        }

        stage('SonarQube Code Scan') {
            steps {
                withCredentials([string(credentialsId: 'sonarqube-creds', variable: 'SONAR_AUTH_TOKEN')]) {
                    withSonarQubeEnv('SonarQube Server') {
                        sh """
                        sonar-scanner \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.sources=src \
                            -Dsonar.host.url=${SONAR_HOST_URL} \
                            -Dsonar.login=${SONAR_AUTH_TOKEN}
                        """
                    }
                }
            }
        }

        stage('Terraform Init & Apply') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir("${env.TERRAFORM_DIR}") {
                        sh '''
                        terraform init || exit 1
                        terraform apply -auto-approve || exit 1
                        '''
                    }
                }
            }
        }

        stage('Build and Push Docker Image to ECR') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                    aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                    aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                    aws configure set default.region ${AWS_REGION}

                    aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URI}

                    docker build -t ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} . || exit 1
                    docker tag ${ECR_REPO_NAME}:${DOCKER_IMAGE_TAG} ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} || exit 1
                    docker push ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} || exit 1
                    '''
                }
            }
        }

        stage('Trivy Scan - Docker Image') {
            steps {
                sh '''
                echo "Running Trivy scan on Docker image..."
                trivy image ${ECR_REPO_URI}:${DOCKER_IMAGE_TAG} > trivy-image-report.txt || true
                '''
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')]) {
                    sh '''
                    helm upgrade --install fraud-detection k8s/helm \
                        --namespace ${K8S_NAMESPACE} \
                        --values k8s/helm/values.yaml \
                        --set image.repository=${ECR_REPO_URI} \
                        --set image.tag=${DOCKER_IMAGE_TAG}
                    '''
                }
            }
        }
    }

    post {
        always {
            node('built-in') {
                archiveArtifacts artifacts: 'trivy-*.txt', allowEmptyArchive: true
                echo 'Cleaning up unused containers created by this pipeline...'
                sh '''
                CONTAINER_ID=$(cat /proc/self/cgroup | grep docker | tail -1 | cut -d'/' -f3)
                docker ps -a -q --filter "status=exited" | grep -v "${CONTAINER_ID}" | grep -v "$(docker ps -q --filter name=sonarqube)" | xargs -r docker rm -f || true
                '''
            }
        }
        success {
            echo '✅ Pipeline completed successfully.'
        }
        failure {
            echo '❌ Pipeline failed. Please check logs.'
        }
    }
}
